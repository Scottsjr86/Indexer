{"path":"Cargo.toml","lang":"toml","sha1":"a806cac41ef28eba2e96a3ede73637a55efc1636","size":278,"last_modified":"1754880027","snippet":"[package]\nname = \"indexer\"\nversion = \"0.1.2\"\nedition = \"2021\"\nresolver = \"1\"\n[dependencies]\nanyhow = \"1.0.98\"\nchrono = { version = \"0.4.41\", features = [\"serde\"] }\nignore = \"0.4.23\"\nserde = { version = \"1.0.219\", features = [\"derive\"] }\nserde_json = \"1.0.142\"\nsha1 = \"0.10.6\"","tags":["toml","dir:cargo.toml","ext:toml"],"summary":"Cargo manifest / workspace config.","token_estimate":62,"role":"config","module":"Cargo","imports":[],"exports":[],"lines_total":14,"lines_nonblank":12,"rel_dir":"Cargo.toml","noise":false}
{"path":"src/chunker.rs","lang":"rust","sha1":"7904e6102dff3130fbe08b0d956e56645dd89f8a","size":6879,"last_modified":"1754877462","snippet":"Build markdown \"paste chunks\" for LLMs from a JSONL index (streaming, robust).\nBackwards-compatible with existing outputs like `chunks/paste_1.md`.  // README/outputs match:contentReference[oaicite:2]{index=2}:contentReference[oaicite:3]{index=3}\nuse anyhow::{\nuse chrono::Utc;\nuse std::{\nuse crate::{\n/// Build markdown \"paste chunks\" for LLMs from a JSONL index (streaming, robust).\n/// Backwards-compatible with existing outputs like `chunks/paste_1.md`.  // README/outputs match:contentReference[oaicite:2]{index=2}:contentReference[oaicite:3]{index=3}\npub fn chunk_index_for_gpt(index_path: &Path, out_prefix: &str, token_cap: usize) -> Result<()> {\n/// Conservative fallback token estimator if index line forgot to set it.\nfn estimate_tokens_fallback(s: &str) -> usize {\n/// Write one chunk file with rich header + per-file sections.\nfn write_chunk(\n/// Normalize fence language to something Markdown renderers recognize.\nfn fence_lang<'a>(lang: &'a str) -> &'a str {\n/// Trim monstrous snippets but keep code fences valid.\nfn trim_snippet(s: &str, max_chars: usize) -> String {","tags":["rust","dir:src","ext:rs"],"summary":"Splits index into paste-friendly markdown chunks.","token_estimate":171,"role":"lib","module":"chunker","imports":["anyhow::{","chrono::Utc","crate::{","std::{"],"exports":["chunk_index_for_gpt"],"lines_total":203,"lines_nonblank":177,"rel_dir":"src","noise":false}
{"path":"src/commands.rs","lang":"rust","sha1":"6c47fa00bff495bea8d8fe8bbecc379bfab3f3d1","size":7874,"last_modified":"1754877473","snippet":"Resolve all standard output paths under .gpt_index for the current working dir.\nuse anyhow::{\nuse std::{\nuse crate::{\npub fn run_cli() -> Result<()> {\n/// Resolve all standard output paths under .gpt_index for the current working dir.\nfn resolve_paths() -> Result<ResolvedPaths> {\nstruct ResolvedPaths {\n#[allow(dead_code)]\nfn index_root(is_reindex: bool) -> Result<()> {\nfn index_subdir() -> Result<()> {\nfn generate_tree() -> Result<()> {\nfn generate_map() -> Result<()> {\n/// Support: `indexer chunk` or `indexer chunk --cap=12000`\nfn chunk_index(arg: Option<&str>) -> Result<()> {\nfn parse_cap(arg: Option<&str>) -> Option<usize> {\nfn ensure_index_exists(p: &Path) -> Result<()> {\nfn print_help() {","tags":["rust","dir:src","ext:rs"],"summary":"Resolve all standard output paths under .gpt_index for the current working dir.","token_estimate":128,"role":"lib","module":"commands","imports":["anyhow::{","crate::{","std::{"],"exports":["run_cli"],"lines_total":218,"lines_nonblank":190,"rel_dir":"src","noise":false}
{"path":"src/diff.rs","lang":"rust","sha1":"9e018a005de45413ebd8d1a91879cde64c453a59","size":4952,"last_modified":"1754877524","snippet":"Compute a structured diff between two index snapshots.\n- Detects adds/removes/modifies\n- Detects renames by matching `sha1` across different paths\n- Emits compact items (path + minimal fields) and a summary\nuse serde_json::{json, Value};\nuse std::collections::{BTreeMap, HashMap};\nuse crate::{\n/// Compute a structured diff between two index snapshots.\n/// - Detects adds/removes/modifies\n/// - Detects renames by matching `sha1` across different paths\n/// - Emits compact items (path + minimal fields) and a summary\npub fn diff_indexes(old: &[FileIntentEntry], new: &[FileIntentEntry]) -> Value {\n/// Minimal JSON for a file to keep diff payloads lean.\nfn json_min(e: &FileIntentEntry) -> Value {","tags":["rust","dir:src","ext:rs"],"summary":"Compute a structured diff between two index snapshots.","token_estimate":134,"role":"lib","module":"diff","imports":["crate::{","serde_json::{json, Value}","std::collections::{BTreeMap, HashMap}"],"exports":["diff_indexes"],"lines_total":134,"lines_nonblank":123,"rel_dir":"src","noise":false}
{"path":"src/file_intent_entry.rs","lang":"rust","sha1":"5e27c6a32b3bce34dda1e3b288e9f499bcfe9572","size":1798,"last_modified":"1754878269","snippet":"\"bin\" | \"lib\" | \"test\" | \"doc\" | \"config\" | \"script\" | \"ui\" | \"core\"\nuse serde::{\n#[derive(Serialize, Deserialize, Clone, Debug)]\n#[serde(default)] // ← lets us read older JSONL that lacks the new fields\npub struct FileIntentEntry {\n/// \"bin\" | \"lib\" | \"test\" | \"doc\" | \"config\" | \"script\" | \"ui\" | \"core\"\n/// Best‑effort module path (lang‑aware), e.g. `scan`, `foo::bar`, or `pkg.module`\n/// Cheap import edges (regex‑free skim)\n/// Cheap public surface (fn/struct/trait/def/class)\n/// Line counts for quick size/churn heuristics\n/// Top-level directory (e.g. \"src\")\n/// True if file lives in noisy infra dirs\nimpl Default for FileIntentEntry {\nfn default() -> Self {","tags":["rust","dir:src","ext:rs"],"summary":"\"bin\" | \"lib\" | \"test\" | \"doc\" | \"config\" | \"script\" | \"ui\" | \"core\"","token_estimate":142,"role":"lib","module":"file_intent_entry","imports":["serde::{"],"exports":["FileIntentEntry"],"lines_total":64,"lines_nonblank":58,"rel_dir":"src","noise":false}
{"path":"src/helpers.rs","lang":"rust","sha1":"6c772aeddf6ad7305093f56673ad9edb361e32f6","size":7616,"last_modified":"1754877653","snippet":"pub fn infer_role(path: &str, lang: &str, snippet: &str) -> String {\npub fn infer_module_id(path: &str, lang: &str) -> String {\npub fn rust_module_id(p: &str) -> String {\npub fn python_module_id(p: &str) -> String {\npub fn skim_symbols(snippet: &str, lang: &str) -> (Vec<String>, Vec<String>) {\npub fn skim_rust(s: &str) -> (Vec<String>, Vec<String>) {\npub fn skim_python(s: &str) -> (Vec<String>, Vec<String>) {\npub fn skim_js_ts(s: &str) -> (Vec<String>, Vec<String>) {\npub fn sig_ident(line: &str, prefix: &str) -> String {\npub fn dedup(mut v: Vec<String>) -> Vec<String> {","tags":["rust","dir:src","ext:rs"],"summary":"pub fn infer_role(path: &str, lang: &str, snippet: &str) -> String {","token_estimate":114,"role":"lib","module":"helpers","imports":[],"exports":["dedup","infer_module_id","infer_role","python_module_id","rust_module_id","sig_ident","skim_js_ts","skim_python","skim_rust","skim_symbols"],"lines_total":204,"lines_nonblank":186,"rel_dir":"src","noise":false}
{"path":"src/intent.rs","lang":"rust","sha1":"399ec043bddcb7ef843153b3b9f348537c834918","size":7310,"last_modified":"1754877687","snippet":"pub fn guess_summary(path: &str, snippet: &str, lang: &str) -> String {\n#[inline]\nfn s(msg: &str) -> String { msg.to_string() }\n#[inline]\nfn contains(hay: &str, needle: &str) -> bool { hay.contains(needle) }\n#[inline]\nfn ends_with(hay: &str, suffix: &str) -> bool { hay.ends_with(suffix) }\n#[inline]\nfn starts_with(hay: &str, prefix: &str) -> bool { hay.starts_with(prefix) }\nfn any_in(hay: &str, needles: &[&str]) -> bool {\n/// Extracts a succinct doc summary from module/file docs or Markdown headings.\nfn extract_doc_summary(s: &str) -> Option<String> {\nfn first_non_empty_line(s: &str) -> Option<String> {","tags":["rust","dir:src","ext:rs"],"summary":"pub fn guess_summary(path: &str, snippet: &str, lang: &str) -> String {","token_estimate":114,"role":"lib","module":"intent","imports":[],"exports":["guess_summary"],"lines_total":173,"lines_nonblank":151,"rel_dir":"src","noise":false}
{"path":"src/main.rs","lang":"rust","sha1":"f7866327e665c256559dd4689bef35b67fb3b787","size":281,"last_modified":"1754877045","snippet":"pub mod chunker;\npub mod commands;\npub mod diff;\npub mod intent;\npub mod map_view;\npub mod scan;\npub mod snippet;\npub mod tree_view;\npub mod file_intent_entry;\npub mod util;\npub mod helpers;\nuse anyhow::Result;\nfn main() -> Result<()> {","tags":["rust","dir:src","ext:rs","crate:bin"],"summary":"Entrypoint for this Rust binary.","token_estimate":54,"role":"bin","module":"bin","imports":["anyhow::Result"],"exports":["chunker","commands","diff","file_intent_entry","helpers","intent","map_view","scan","snippet","tree_view","util"],"lines_total":19,"lines_nonblank":16,"rel_dir":"src","noise":false}
{"path":"src/map_view.rs","lang":"rust","sha1":"6a61dedcd7c9801187e015f83a8b54024ed7d373","size":6217,"last_modified":"1754878465","snippet":"Build a hierarchical, skim-friendly project map from a JSONL index.\n- Groups by top-level directory\n- Summaries are clamped to a single tight line\n- Per-directory caps (with \"+N more…\" footer) keep output readable\n- Skips obvious noise directories (configurable below)\nuse std::{\nuse crate::{\n/// Build a hierarchical, skim-friendly project map from a JSONL index.\n/// - Groups by top-level directory\n/// - Summaries are clamped to a single tight line\n/// - Per-directory caps (with \"+N more…\" footer) keep output readable\n/// - Skips obvious noise directories (configurable below)\npub fn build_map_from_index(index_path: &Path, output_path: &Path) -> std::io::Result<()> {\n#[allow(unused_variables)]\n#[derive(Clone)]\nstruct EntryLite {\nfn split_top(path: &str) -> (String, String) {\nfn clamp_summary(s: &str) -> String {\nfn truncate_ellipsis(s: &str, max: usize) -> String {\nfn top_k_tags(freq: &BTreeMap<String, usize>, k: usize) -> (String, usize) {","tags":["rust","dir:src","ext:rs"],"summary":"Builds hierarchical project map (markdown).","token_estimate":182,"role":"ui","module":"map_view","imports":["crate::{","std::{"],"exports":["build_map_from_index"],"lines_total":202,"lines_nonblank":177,"rel_dir":"src","noise":false}
{"path":"src/scan.rs","lang":"rust","sha1":"9dfded355948de4e04b152b80a5a8b398a725d5c","size":7901,"last_modified":"1754879348","snippet":"use anyhow::{\nuse ignore::{\nuse sha1::{\nuse std::{\nuse crate::{\npub fn scan_and_write_index(root: &Path, out: &Path) -> Result<Vec<FileIntentEntry>> {\npub fn index_project(root: &Path) -> Result<Vec<FileIntentEntry>> {\npub fn estimate_tokens(s: &str) -> usize {\npub fn read_index(path: &Path) -> Result<Vec<FileIntentEntry>> {\nfn normalize_rel(root: &Path, path: &Path) -> String {\nfn is_probably_binary(path: &Path) -> Result<bool> {\nfn detect_lang(path: &Path) -> Option<String> {\nfn ext_to_lang(ext: &str) -> String {","tags":["rust","dir:src","ext:rs"],"summary":"Project indexer: walk, hash, snippet, summarize.","token_estimate":88,"role":"lib","module":"scan","imports":["anyhow::{","crate::{","ignore::{","sha1::{","std::{"],"exports":["estimate_tokens","index_project","read_index","scan_and_write_index"],"lines_total":258,"lines_nonblank":228,"rel_dir":"src","noise":false}
{"path":"src/snippet.rs","lang":"rust","sha1":"8ddcf14ebaa646f76cf76fe090d4e86d9040e738","size":8285,"last_modified":"1754878501","snippet":"------------------------- scoring + helpers -------------------------\npub fn extract_relevant_snippet(content: &str, lang: &str) -> String {\nfn score_line(l: &str, lang: &str) -> u8 {\nfn score_rust(l: &str, ll: &str) -> u8 {\nif ll.contains(\"todo\") || ll.contains(\"fixme\") { return 2; }\nfn score_python(l: &str, ll: &str) -> u8 {\nif ll.contains(\"todo\") || ll.contains(\"fixme\") { return 2; }\nfn score_js_ts(l: &str, _ll: &str) -> u8 {\nfn score_go(l: &str, _ll: &str) -> u8 {\nfn score_config(l: &str, _ll: &str) -> u8 {\nfn score_md(l: &str, _ll: &str) -> u8 {\nfn score_generic(l: &str, _ll: &str) -> u8 {\nfn leading_doc_block(s: &str, lang: &str) -> Option<Vec<String>> {\nfn strip_rust_doc(t: &str) -> &str {\nfn normalize_doc(lines: Vec<String>) -> Vec<String> {\nfn push_lines(out: &mut Vec<String>, lines: Vec<String>) {\nfn join(lines: &[String]) -> String {","tags":["rust","dir:src","ext:rs"],"summary":"------------------------- scoring + helpers -------------------------","token_estimate":170,"role":"lib","module":"snippet","imports":[],"exports":["extract_relevant_snippet"],"lines_total":230,"lines_nonblank":203,"rel_dir":"src","noise":false}
{"path":"src/tree_view.rs","lang":"rust","sha1":"82d7e5ea0e6865320ee2c06aef01ddcc7504cd18","size":5042,"last_modified":"1754878914","snippet":"Build a hierarchical markdown tree from the JSONL index.\nOutput format (example):\n- src/\n- commands.rs — Run CLI entrypoints [rust]\n- tree_view.rs — Builds the directory tree [rust]\n- README.md — Project overview [md]\nuse anyhow::Context;\nuse std::{\nuse std::fs::File;\nuse std::io::{\nuse std::path::{\nuse crate::{\n/// Build a hierarchical markdown tree from the JSONL index.\n///\n/// Output format (example):\n/// - src/\n///   - commands.rs — Run CLI entrypoints [rust]\n///   - tree_view.rs — Builds the directory tree [rust]\n/// - README.md — Project overview [md]\npub fn build_tree_from_index(index_path: &Path, output_path: &Path) -> std::io::Result<()> {\nfn render_dir(\nfn norm(p: &Path) -> String {\nfn join(base: &str, tail: &str) -> String {\nfn indent(out: &mut File, depth: usize) -> std::io::Result<()> {\nfn to_io<E: std::fmt::Display>(e: E) -> std::io::Error {","tags":["rust","dir:src","ext:rs"],"summary":"Builds project directory tree (markdown).","token_estimate":174,"role":"ui","module":"tree_view","imports":["anyhow::Context","crate::{","std::fs::File","std::io::{","std::path::{","std::{"],"exports":["build_tree_from_index"],"lines_total":150,"lines_nonblank":132,"rel_dir":"src","noise":false}
{"path":"src/util.rs","lang":"rust","sha1":"e7d9986e170e5c795db1e466e71b2fe2f6e060fa","size":5205,"last_modified":"1754878944","snippet":"Best-effort current directory name, canonicalized, safe for filenames.\nFallbacks to env vars or \"project\" instead of erroring.\nuse std::{\n/// Best-effort current directory name, canonicalized, safe for filenames.\n/// Fallbacks to env vars or \"project\" instead of erroring.\npub fn get_dir_name() -> std::io::Result<String> {\n/// RFC3339 (sortable) + a compact stamp string.\npub fn now_timestamp() -> String {\nuse chrono::{Local, SecondsFormat};\n/// RFC3339 (sortable) + a compact, filesystem-safe stamp.\npub fn now_ts_compact() -> String {\nuse chrono::{Local, Datelike, Timelike};\n/// Modified time → UNIX seconds. Falls back to created() if needed.\npub fn to_unix_epoch(meta: &Metadata) -> String {\nuse std::time::{SystemTime, UNIX_EPOCH};\nfn secs(t: SystemTime) -> Option<String> {\n/// Heuristic tagger: case-insensitive signals from path + language.\n/// Adds structural tags (dir:..., ext:...) to help downstream filtering.\npub fn infer_tags(path: &str, lang: &str) -> Vec<String> {\nuse std::path::Component;\nfn project_name_from_path(p: &Path) -> String {\nfn slugify(s: &str) -> String {\nfn normalize_lang<'a>(lang: &'a str) -> &'a str {\nfn dedup_preserve_order(mut v: Vec<String>) -> Vec<String> {\nuse std::collections::HashSet;","tags":["rust","dir:src","ext:rs"],"summary":"Filesystem / IO utilities.","token_estimate":222,"role":"lib","module":"util","imports":["chrono::{Local, Datelike, Timelike}","chrono::{Local, SecondsFormat}","std::collections::HashSet","std::path::Component","std::time::{SystemTime, UNIX_EPOCH}","std::{"],"exports":["get_dir_name","infer_tags","now_timestamp","now_ts_compact","to_unix_epoch"],"lines_total":147,"lines_nonblank":129,"rel_dir":"src","noise":false}
